<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Игра со спичками</title>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-X4QJLM5LTM"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-X4QJLM5LTM');
  </script>
  <style>
    @font-face {
      font-family: 'Noto Emoji';
      src: url('https://fonts.googleapis.com/css2?family=Noto+Emoji&display=swap');
    }
    body {
      text-align: center;
      font-family: Arial, 'Noto Emoji', sans-serif;
      margin: 10px;
      background: #1C2526;
      color: #D3D3D3;
      min-height: 100vh;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #game-area {
      width: 300px;
      height: 300px;
      background: #666666;
      border: 1px solid #606060;
      position: relative;
      margin: 10px auto;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .match {
      position: absolute;
      width: 55px;
      height: 5px;
      background: #DAA520;
      border: 1px solid #8B4513;
      transform-origin: center;
    }
    .match.with-shadow {
      box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    .match-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #FF4040;
      border-radius: 50%;
      right: -5px;
      top: -2.5px;
    }
    #result-panel {
      width: 300px;
      margin: 10px auto;
      padding: 10px;
      border-radius: 5px;
      display: grid;
      grid-template-columns: 100px 160px 40px;
      gap: 0;
    }
    #question {
      grid-column: 1 / -1;
      text-align: center;
      font-weight: bold;
      margin-bottom: 0px;
    }
    .result-row {
      display: contents;
    }
    .result-row label {
      text-align: right;
      white-space: nowrap;
      padding: 5px 5px 5px 0;
    }
    .result-row .input-container {
      padding: 5px 5px 5px 0;
    }
    .result-row .arrow {
      font-size: 28px;
      vertical-align: middle;
    }
    .result-row .feedback {
      text-align: left;
      padding: 10px;
    }
    .input-container {
      display: flex;
      align-items: center;
      gap: 5px;
      width: 160px;
    }
    .input-container button {
      padding: 5px 10px;
      width: 30px;
      height: 30px;
      font-size: 16px;
      line-height: 1;
    }
    .input-container input {
      margin-right: 0;
    }
    .correct { color: #00FF00; }
    .incorrect { color: #FF0000; }
    button {
      padding: 10px 20px;
      background: #606060;
      color: #D3D3D3;
      border: none;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #808080;
    }
    #check-btn {
      display: none;
    }
    input[type="number"] {
      background: #606060;
      color: #FFFFFF;
      border: 1px solid #808080;
      padding: 5px;
      width: 50px;
      text-align: center;
      -moz-appearance: textfield;
    }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    select {
      padding: 5px;
      background: #606060;
      color: #D3D3D3;
      border: 1px solid #808080;
      width: 80px;
      text-align: center;
    }
    #new-game-btn {
      display: none;
      margin: 0 10px;
    }
    #settings-btn {
      margin: 0 10px;
    }
    #controls-container {
      margin: 48px auto 10px;
      text-align: center;
      width: 300px;
    }
    #rules {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #2C3536;
      padding: 20px;
      text-align: center;
      font-size: 16px;
      color: #D3D3D3;
      overflow-y: auto;
      z-index: 1000;
      box-sizing: border-box;
    }
    #rules-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: left;
      padding: 20px;
      background: #3A4445;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    #close-rules-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 6px 12px;
      font-size: 14px;
      background: #808080;
      color: #D3D3D3;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #close-rules-btn:hover {
      background: #A0A0A0;
    }
    #custom-keyboard {
      margin: 10px auto;
      width: 300px;
      background: #2C3536;
      padding: 10px;
      border-radius: 5px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }
    #settings-panel {
      margin: 10px auto;
      width: 300px;
      background: #2C3536;
      padding: 10px;
      border-radius: 5px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }
    #settings-panel .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 0;
    }
    #settings-panel .setting-row label {
      flex: 1;
      text-align: left;
      padding-right: 10px;
    }
    #settings-panel .setting-row button,
    #settings-panel .setting-row select {
      flex: 1;
      max-width: 150px;
    }
    #settings-panel .setting-row .input-container {
      flex: 1;
      max-width: 150px;
      display: flex;
      gap: 5px;
    }
    #custom-keyboard .spacer {
      visibility: hidden;
    }
    #custom-keyboard button,
    #settings-panel button {
      padding: 10px;
      font-size: 16px;
      background: #606060;
      color: #D3D3D3;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #custom-keyboard button:hover,
    #settings-panel button:hover {
      background: #808080;
    }
    #custom-keyboard .delete-btn {
      background: #606060;
    }
    #custom-keyboard .delete-btn:hover {
      background: #808080;
    }
    input.active {
      border: 2px solid #DAA520;
    }
    #button-container {
      height: 40px;
      margin-bottom: 5px;
      text-align: center;
    }
    .custom-select {
      background: #606060;
      color: #D3D3D3;
      border: 1px solid #808080;
      padding: 5px;
      width: 50px;
      text-align: center;
      line-height: 20px;
    }
    body.light-theme {
      background: #F5F5F5;
      color: #333333;
    }
    .light-theme #game-area {
      background: #FFFFFF;
      border: 1px solid #CCCCCC;
    }
    .light-theme button {
      background: #4CAF50;
      color: #FFFFFF;
    }
    .light-theme button:hover {
      background: #45A049;
    }
    .light-theme input[type="number"] {
      background: #FFFFFF;
      color: #333333;
      border: 1px solid #CCCCCC;
    }
    .light-theme select,
    .light-theme .custom-select {
      background: #FFFFFF;
      color: #333333;
      border: 1px solid #CCCCCC;
    }
    .light-theme #custom-keyboard,
    .light-theme #settings-panel {
      background: #E0E0E0;
    }
    .light-theme #custom-keyboard button,
    .light-theme #settings-panel button {
      background: #4CAF50;
      color: #FFFFFF;
    }
    .light-theme #custom-keyboard button:hover,
    .light-theme #settings-panel button:hover {
      background: #45A049;
    }
    .light-theme #rules {
      background: #F5F5F5;
    }
    .light-theme #rules-content {
      background: #FFFFFF;
      color: #333333;
    }
    .light-theme #close-rules-btn {
      background: #4CAF50;
      color: #FFFFFF;
    }
    .light-theme #close-rules-btn:hover {
      background: #45A049;
    }
  </style>
</head>
<body>
  <div id="button-container">
    <button id="check-btn" onclick="checkAnswers()">Проверить</button>
    <button id="new-game-btn" onclick="resetGame(event)">Новая игра</button>
  </div>
  <div id="game-area" onclick="handleGameAreaClick(event)"></div>
  <button id="start-btn" onclick="startGame()">Начать</button>
  <div id="result-panel">
    <div id="question">Сколько спичек?</div>
    <div class="result-row">
      <label>Вверх <span class="arrow">↑</span></label>
      <div class="input-container">
        <button onclick="changeAnswer('up', -1)">−</button>
        <input id="up" type="number" readonly>
        <button onclick="changeAnswer('up', 1)">+</button>
      </div>
      <span id="feedback-up" class="feedback"></span>
    </div>
    <div class="result-row">
      <label>Вниз <span class="arrow">↓</span></label>
      <div class="input-container">
        <button onclick="changeAnswer('down', -1)">−</button>
        <input id="down" type="number" readonly>
        <button onclick="changeAnswer('down', 1)">+</button>
      </div>
      <span id="feedback-down" class="feedback"></span>
    </div>
    <div class="result-row">
      <label>Вправо <span class="arrow">→</span></label>
      <div class="input-container">
        <button onclick="changeAnswer('right', -1)">−</button>
        <input id="right" type="number" readonly>
        <button onclick="changeAnswer('right', 1)">+</button>
      </div>
      <span id="feedback-right" class="feedback"></span>
    </div>
    <div class="result-row">
      <label>Влево <span class="arrow">←</span></label>
      <div class="input-container">
        <button onclick="changeAnswer('left', -1)">−</button>
        <input id="left" type="number" readonly>
        <button onclick="changeAnswer('left', 1)">+</button>
      </div>
      <span id="feedback-left" class="feedback"></span>
    </div>
  </div>
  <div id="custom-keyboard">
    <button onclick="addNumber('1')">1</button>
    <button onclick="addNumber('2')">2</button>
    <button onclick="addNumber('3')">3</button>
    <button onclick="addNumber('4')">4</button>
    <button onclick="addNumber('5')">5</button>
    <button onclick="addNumber('6')">6</button>
    <button onclick="addNumber('7')">7</button>
    <button onclick="addNumber('8')">8</button>
    <button onclick="addNumber('9')">9</button>
    <button onclick="deleteNumber()" class="delete-btn">⌫</button>
    <button onclick="addNumber('0')">0</button>
    <button onclick="checkAnswers()">ОК</button>
  </div>
  <div id="controls-container">
    <button id="settings-btn" onclick="toggleSettings()">Настройки</button>
  </div>
  <div id="settings-panel">
    <div class="setting-row">
      <label>Клавиатура:</label>
      <button id="toggle-keyboard-btn" onclick="toggleKeyboard()">Клавиатура (вкл)</button>
    </div>
    <div class="setting-row">
      <label>Язык:</label>
      <select id="language-select" onchange="changeLanguage()">
        <option value="ru">Русский</option>
        <option value="uk">Українська</option>
        <option value="en">English</option>
        <option value="es">Español</option>
        <option value="symbols">🛸</option>
      </select>
    </div>
    <div class="setting-row">
      <label>Тень:</label>
      <button id="shadow-btn" onclick="toggleShadow()">Тень</button>
    </div>
    <div class="setting-row">
      <label>Правила:</label>
      <button id="rules-btn" onclick="toggleRules()">Правила</button>
    </div>
    <div class="setting-row">
      <label>Количество спичек:</label>
      <div class="input-container">
        <button onclick="changeMatchCount(-1)">−</button>
        <div id="match-count" class="custom-select">3</div>
        <button onclick="changeMatchCount(1)">+</button>
      </div>
    </div>
    <div class="setting-row">
      <label>Время созерцания:</label>
      <div class="input-container">
        <button onclick="changeViewTime(-1)">−</button>
        <div id="view-time" class="custom-select">3 сек</div>
        <button onclick="changeViewTime(1)">+</button>
      </div>
    </div>
    <div class="setting-row">
      <label>Тема:</label>
      <button id="theme-btn" onclick="toggleTheme()">Ночь</button>
    </div>
  </div>
  <div id="rules">
    <button id="close-rules-btn" onclick="toggleRules()">Закрыть</button>
    <div id="rules-content">
      <p><strong>Правила игры:</strong></p>
      <p>1. Выбери количество спичек и время созерцания в настройках.</p>
      <p>2. Нажми "Начать".</p>
      <p>3. Запомни направления спичек за отведенное время.</p>
      <p>4. Укажи, сколько головок смотрит вверх, вниз, вправо, влево.</p>
      <p>5. Нажми "Проверить" или кликни по полю для проверки результата.</p>
      <p>6. Нажми "Новая игра" или кликни по полю для новой игры.</p>
      <p><strong>Направления спичек:</strong></p>
      <p>Головка (красный круг) указывает направление по часовой системе:</p>
      <pre>
0°/360° (Вверх)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(влево) 9     3 (Вправо)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (Вниз)
      </pre>
      <p>- 315°–45°: Вверх (около 12 часов)</p>
      <p>- 45°–135°: Вправо (около 3 часов)</p>
      <p>- 135°–225°: Вниз (около 6 часов)</p>
      <p>- 225°–315°: Влево (около 9 часов)</p>
      <p><strong>Цель:</strong> Развитие контроля внимания, тренировка внутреннего взора.</p>
      <p><strong>Процесс:</strong> Остановить внутренний диалог, бросить быстрый короткий взгляд (сфотографировать).</p>
      <p><strong>Возможные побочные действия:</strong> Через годы тренировок внимание внутреннего взора оживает, становится подобно вниманию сновидения за счёт большого вложения энергии. Это может задействоваться в грёзах и ясновидении.</p>
      <p><strong>Рекомендации:</strong> В день делать много повторов. Если получается удержать картинку на мгновение, сделай минимум 60 повторов. Первый этап — удерживать картинку во внутреннем взоре минуту.</p>
    </div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    const debug = true;

    function logDebug(message, data = null) {
      if (debug) {
        console.log(`[DEBUG] ${message}`, data || '');
      }
    }

    const translations = {
      ru: {
        keyboard: 'Клавиатура',
        keyboard_on: 'Клавиатура (вкл)',
        language: 'Язык',
        shadow: 'Тень',
        shadow_on: 'Тень (вкл)',
        rules: 'Правила',
        match_count: 'Количество спичек',
        view_time: 'Время созерцания',
        theme: 'Тема',
        night: 'Ночь',
        day: 'День',
        start: 'Начать',
        check: 'Проверить',
        new_game: 'Новая игра',
        settings: 'Настройки',
        settings_on: 'Настройки (вкл)',
        close: 'Закрыть',
        question: 'Сколько спичек?',
        up: 'Вверх ↑',
        down: 'Вниз ↓',
        right: 'Вправо →',
        left: 'Влево ←',
        ok: 'ОК',
        delete: '⌫',
        seconds: 'сек',
        rules_content: `
          <p><strong>Правила игры:</strong></p>
          <p>1. Выбери количество спичек и время созерцания в настройках.</p>
          <p>2. Нажми "Начать".</p>
          <p>3. Запомни направления спичек за отведенное время.</p>
          <p>4. Укажи, сколько головок смотрит вверх, вниз, вправо, влево.</p>
          <p>5. Нажми "Проверить" или кликни по полю для проверки результата.</p>
          <p>6. Нажми "Новая игра" или кликни по полю для новой игры.</p>
          <p><strong>Направления спичек:</strong></p>
          <p>Головка (красный круг) указывает направление по часовой системе:</p>
          <pre>
0°/360° (Вверх)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(влево) 9     3 (Вправо)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (Вниз)
          </pre>
          <p>- 315°–45°: Вверх (около 12 часов)</p>
          <p>- 45°–135°: Вправо (около 3 часов)</p>
          <p>- 135°–225°: Вниз (около 6 часов)</p>
          <p>- 225°–315°: Влево (около 9 часов)</p>
          <p><strong>Цель:</strong> Развитие контроля внимания, тренировка внутреннего взора.</p>
          <p><strong>Процесс:</strong> Остановить внутренний диалог, бросить быстрый короткий взгляд (сфотографировать).</p>
          <p><strong>Возможные побочные действия:</strong> Через годы тренировок внимание внутреннего взора оживает, становится подобно вниманию сновидения за счёт большого вложения энергии. Это может задействоваться в грёзах и ясновидении.</p>
          <p><strong>Рекомендации:</strong> В день делать много повторов. Если получается удержать картинку на мгновение, сделай минимум 60 повторов. Первый этап — удерживать картинку во внутреннем взоре минуту.</p>
        `
      },
      uk: {
        keyboard: 'Клавіатура',
        keyboard_on: 'Клавіатура (увімк)',
        language: 'Мова',
        shadow: 'Тінь',
        shadow_on: 'Тінь (увімк)',
        rules: 'Правила',
        match_count: 'Кількість сірників',
        view_time: 'Час споглядання',
        theme: 'Тема',
        night: 'Ніч',
        day: 'День',
        start: 'Почати',
        check: 'Перевірити',
        new_game: 'Нова гра',
        settings: 'Налаштування',
        settings_on: 'Налаштування (увімк)',
        close: 'Закрити',
        question: 'Скільки сірників?',
        up: 'Вгору ↑',
        down: 'Вниз ↓',
        right: 'Вправо →',
        left: 'Вліво ←',
        ok: 'ОК',
        delete: '⌫',
        seconds: 'сек',
        rules_content: `
          <p><strong>Правила гри:</strong></p>
          <p>1. Обери кількість сірників і час споглядання в налаштуваннях.</p>
          <p>2. Натисни "Почати".</p>
          <p>3. Запам'ятай напрямки сірників за відведений час.</p>
          <p>4. Вкажи, скільки голівок дивиться вгору, вниз, вправо, вліво.</p>
          <p>5. Натисни "Перевірити" або клацни по полю для перевірки результату.</p>
          <p>6. Натисни "Нова гра" або клацни по полю для нової гри.</p>
          <p><strong>Напрямки сірників:</strong></p>
          <p>Голівка (червоний круг) вказує напрямок за годинниковою системою:</p>
          <pre>
0°/360° (Вгору)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(вліво) 9     3 (Вправо)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (Вниз)
          </pre>
          <p>- 315°–45°: Вгору (близько 12 години)</p>
          <p>- 45°–135°: Вправо (близько 3 години)</p>
          <p>- 135°–225°: Вниз (близько 6 години)</p>
          <p>- 225°–315°: Вліво (близько 9 години)</p>
          <p><strong>Мета:</strong> Розвиток контролю уваги, тренування внутрішнього зору.</p>
          <p><strong>Процес:</strong> Зупинити внутрішній діалог, кинути швидкий короткий погляд (сфотографувати).</p>
          <p><strong>Можливі побічні ефекти:</strong> Через роки тренувань увага внутрішнього зору оживає, стає подібною до уваги сновидінь завдяки великим вкладенням енергії. Це може використовуватися в мріях і ясновидінні.</p>
          <p><strong>Рекомендації:</strong> У день роби багато повторів. Якщо вдається утримати картинку на мить, виконай щонайменше 60 повторів. Перший етап — утримувати картинку у внутрішньому зорі хвилину.</p>
        `
      },
      en: {
        keyboard: 'Keyboard',
        keyboard_on: 'Keyboard (on)',
        language: 'Language',
        shadow: 'Shadow',
        shadow_on: 'Shadow (on)',
        rules: 'Rules',
        match_count: 'Number of matches',
        view_time: 'Viewing time',
        theme: 'Theme',
        night: 'Night',
        day: 'Day',
        start: 'Start',
        check: 'Check',
        new_game: 'New game',
        settings: 'Settings',
        settings_on: 'Settings (on)',
        close: 'Close',
        question: 'How many matches?',
        up: 'Up ↑',
        down: 'Down ↓',
        right: 'Right →',
        left: 'Left ←',
        ok: 'OK',
        delete: '⌫',
        seconds: 'sec',
        rules_content: `
          <p><strong>Game Rules:</strong></p>
          <p>1. Choose the number of matches and viewing time in settings.</p>
          <p>2. Press "Start".</p>
          <p>3. Memorize the directions of the matches within the allotted time.</p>
          <p>4. Indicate how many match heads point up, down, right, and left.</p>
          <p>5. Press "Check" or click the field to check the result.</p>
          <p>6. Press "New game" or click the field for a new game.</p>
          <p><strong>Match Directions:</strong></p>
          <p>The match head (red circle) indicates the direction based on the clock system:</p>
          <pre>
0°/360° (Up)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(left) 9     3 (Right)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (Down)
          </pre>
          <p>- 315°–45°: Up (around 12 o'clock)</p>
          <p>- 45°–135°: Right (around 3 o'clock)</p>
          <p>- 135°–225°: Down (around 6 o'clock)</p>
          <p>- 225°–315°: Left (around 9 o'clock)</p>
          <p><strong>Goal:</strong> Develop attention control and train the inner vision.</p>
          <p><strong>Process:</strong> Stop the inner dialogue, take a quick short glance (snapshot).</p>
          <p><strong>Possible side effects:</strong> After years of training, the attention of the inner vision comes alive, becoming similar to dream attention due to significant energy investment. This can be engaged in daydreams and clairvoyance.</p>
          <p><strong>Recommendations:</strong> Do many repetitions daily. If you can hold the image for a moment, do at least 60 repetitions. The first stage is to hold the image in your inner vision for a minute.</p>
        `
      },
      es: {
        keyboard: 'Teclado',
        keyboard_on: 'Teclado (activado)',
        language: 'Idioma',
        shadow: 'Sombra',
        shadow_on: 'Sombra (activada)',
        rules: 'Reglas',
        match_count: 'Número de cerillas',
        view_time: 'Tiempo de observación',
        theme: 'Tema',
        night: 'Noche',
        day: 'Día',
        start: 'Comenzar',
        check: 'Verificar',
        new_game: 'Nuevo juego',
        settings: 'Configuración',
        settings_on: 'Configuración (activada)',
        close: 'Cerrar',
        question: '¿Cuántas cerillas?',
        up: 'Arriba ↑',
        down: 'Abajo ↓',
        right: 'Derecha →',
        left: 'Izquierda ←',
        ok: 'OK',
        delete: '⌫',
        seconds: 'seg',
        rules_content: `
          <p><strong>Reglas del juego:</strong></p>
          <p>1. Elige el número de cerillas y el tiempo de observación en la configuración.</p>
          <p>2. Presiona "Comenzar".</p>
          <p>3. Memoriza las direcciones de las cerillas en el tiempo asignado.</p>
          <p>4. Indica cuántas cabezas de cerillas apuntan hacia arriba, abajo, derecha e izquierda.</p>
          <p>5. Presiona "Verificar" o haz clic en el campo para comprobar el resultado.</p>
          <p>6. Presiona "Nuevo juego" o haz clic en el campo para un nuevo juego.</p>
          <p><strong>Direcciones de las cerillas:</strong></p>
          <p>La cabeza de la cerilla (círculo rojo) indica la dirección según el sistema de reloj:</p>
          <pre>
0°/360° (Arriba)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(izquierda) 9     3 (Derecha)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (Abajo)
          </pre>
          <p>- 315°–45°: Arriba (alrededor de las 12 en punto)</p>
          <p>- 45°–135°: Derecha (alrededor de las 3 en punto)</p>
          <p>- 135°–225°: Abajo (alrededor de las 6 en punto)</p>
          <p>- 225°–315°: Izquierda (alrededor de las 9 en punto)</p>
          <p><strong>Objetivo:</strong> Desarrollar el control de la atención y entrenar la visión interna.</p>
          <p><strong>Proceso:</strong> Detener el diálogo interno, dar una mirada rápida y breve (capturar).</p>
          <p><strong>Efectos secundarios posibles:</strong> Después de años de entrenamiento, la atención de la visión interna cobra vida, volviéndose similar a la atención de los sueños debido a una gran inversión de energía. Esto puede involucrarse en ensoñaciones y clarividencia.</p>
          <p><strong>Recomendaciones:</strong> Realiza muchas repeticiones diarias. Si puedes mantener la imagen por un momento, haz al menos 60 repeticiones. La primera etapa es mantener la imagen en tu visión interna durante un minuto.</p>
        `
      },
      symbols: {
        keyboard: '🛸',
        keyboard_on: '🛸✅',
        language: '🛸',
        shadow: '🛸',
        shadow_on: '🛸✅',
        rules: '🛸',
        match_count: '🛸',
        view_time: '🛸',
        theme: '🛸',
        night: '🛸',
        day: '🛸',
        start: '🛸',
        check: '🛸',
        new_game: '🛸',
        settings: '🛸',
        settings_on: '🛸✅',
        close: '🛸',
        question: '🛸❓',
        up: '⬆️',
        down: '⬇️',
        right: '➡️',
        left: '⬅️',
        ok: '🛸',
        delete: '⌫',
        seconds: '🛸',
        rules_content: `
          <p><strong>🛸:</strong></p>
          <p>1. 🛸🔥🛸</p>
          <p>2. 🛸</p>
          <p>3. 🧠🔄🔥🛸</p>
          <p>4. 🔢⬆️⬇️➡️⬅️</p>
          <p>5. 🛸🖼️</p>
          <p>6. 🛸🖼️</p>
          <p><strong>🔥🧭:</strong></p>
          <p>🔴🧭🕰️:</p>
          <pre>
0°/360° (⬆️)
    12
     ↑
     |> 
     |
315°  |  45°
↖ 11  |  1 ↗  
  ↖   |   ↗    
    ↖ | ↗      
10  ↖ | ↗  2    
     ↖| ↗        
270° <-----+-----> 90°
(⬅️) 9     3 (➡️)
     ↙| ↘        
    ↙ |  ↘      
  ↙   |   ↘    
↙  8  |  4  ↘  
180°   |   135°
      | 
      | 
      ↓
    6 (⬇️)
          </pre>
          <p>- 315°–45°: ⬆️ (🕛)</p>
          <p>- 45°–135°: ➡️ (🕒)</p>
          <p>- 135°–225°: ⬇️ (🕕)</p>
          <p>- 225°–315°: ⬅️ (🕘)</p>
          <p><strong>🎯:</strong> 🧠👀</p>
          <p><strong>🔄:</strong> 🤫📸</p>
          <p><strong>⚠️:</strong> 🕰️🧠👀💤💡</p>
          <p><strong>📝:</strong> 🔁60🔄👀1⏳</p>
        `
      }
    };

    let matches = [];
    let matchPositions = [];
    let gameStarted = false;
    let activeInput = null;
    let shadowEnabled = false;
    let keyboardEnabled = true;
    let matchCount = 3;
    let viewTime = 3000;
    let restartCount = 0;
    let sessionId = generateSessionId();
    let gameStartTime = null;
    let lastInteraction = performance.now();
    let isDarkTheme = true;
    let currentLanguage = 'ru';

    const matchCountDisplay = document.getElementById('match-count');
    const viewTimeDisplay = document.getElementById('view-time');

    function generateSessionId() {
      const id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
      logDebug('Generated session ID', { sessionId: id });
      return id;
    }

    function setUserProperties() {
      const properties = {
        preferred_language: currentLanguage,
        shadow_preference: shadowEnabled ? 'on' : 'off',
        keyboard_preference: keyboardEnabled ? 'on' : 'off',
        average_match_count: matchCount,
        average_view_time: viewTime / 1000,
        theme_preference: isDarkTheme ? 'dark' : 'light'
      };
      gtag('set', 'user_properties', properties);
      logDebug('Set user properties', properties);
    }

    window.addEventListener('load', () => {
      const eventData = {
        platform: 'Telegram WebApp',
        version: '1.0',
        language: currentLanguage,
        session_id: sessionId
      };
      gtag('event', 'game_init', eventData);
      logDebug('Game initialized', eventData);
      setUserProperties();
      changeLanguage();
    });

    matchCountDisplay.textContent = matchCount;
    viewTimeDisplay.textContent = viewTime / 1000 + ' ' + translations[currentLanguage].seconds;

    const inputs = document.querySelectorAll('#result-panel input');
    inputs.forEach(input => {
      input.addEventListener('click', () => {
        inputs.forEach(inp => inp.classList.remove('active'));
        input.classList.add('active');
        activeInput = input;
        lastInteraction = performance.now();
        logDebug('Input selected', { input: input.id });
      });
    });

    document.addEventListener('click', () => {
      lastInteraction = performance.now();
    });

    setInterval(() => {
      if (gameStarted && performance.now() - lastInteraction > 30000) {
        const eventData = {
          pause_duration: 30,
          reason: 'inactivity',
          session_id: sessionId
        };
        gtag('event', 'game_pause', eventData);
        logDebug('Game paused', eventData);
      }
    }, 30000);

    window.onerror = function(message, source, lineno, colno, error) {
      const eventData = {
        message: message,
        source: source,
        line: lineno,
        column: colno,
        session_id: sessionId
      };
      gtag('event', 'javascript_error', eventData);
      logDebug('JavaScript error', eventData);
    };

    function handleGameAreaClick(event) {
      event.stopPropagation();
      const rect = document.getElementById('game-area').getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      
      const eventData = {
        action: gameStarted && document.getElementById('check-btn').style.display === 'inline-block' ? 'check_answers' : 'reset_game',
        click_coordinates: JSON.stringify({ x: clickX, y: clickY }),
        session_id: sessionId,
        user_id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous'
      };
      gtag('event', 'game_area_click', eventData);
      logDebug('Game area clicked', eventData);

      lastInteraction = performance.now();
      if (gameStarted && document.getElementById('check-btn').style.display === 'inline-block') {
        checkAnswers();
      } else {
        resetGame(event);
      }
    }

    function startGame() {
      logDebug('Starting game');
      document.getElementById('start-btn').style.display = 'none';
      const gameArea = document.getElementById('game-area');
      gameArea.innerHTML = '';
      matches = [];
      matchPositions = [];
      const matchCountValue = parseInt(matchCountDisplay.textContent);
      const viewTimeValue = parseInt(viewTimeDisplay.textContent) * 1000;
      gameStarted = true;
      gameStartTime = performance.now();

      const difficulty = calculateDifficulty(matchCountValue, viewTimeValue);
      
      const eventData = {
        match_count: matchCountValue,
        view_time: viewTimeValue,
        difficulty: difficulty,
        session_id: sessionId,
        user_id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous',
        match_distribution: JSON.stringify({
          up: 0,
          down: 0,
          right: 0,
          left: 0
        })
      };
      gtag('event', 'game_start', eventData);
      logDebug('Game started', eventData);

      const placedPositions = [];
      for (let i = 0; i < matchCountValue; i++) {
        let x, y, angle, validPosition = false;

        for (let attempt = 0; attempt < 50; attempt++) {
          x = Math.random() * (300 - 65) + 10;
          y = Math.random() * (300 - 65) + 10;
          angle = Math.random() * 360;
          const headOffsetX = Math.cos(angle * Math.PI / 180) * 55;
          const headOffsetY = Math.sin(angle * Math.PI / 180) * 55;
          const headX = x + headOffsetX;
          const headY = y + headOffsetY;

          if (
            x >= 10 && x <= 290 &&
            y >= 10 && y <= 290 &&
            headX >= 10 && headX <= 290 &&
            headY >= 10 && headY <= 290
          ) {
            validPosition = true;
            break;
          }
        }

        if (!validPosition) {
          x = 150;
          y = 150;
          console.warn(`Match ${i + 1} placed at default position due to invalid positioning`);
          const errorData = {
            error_type: 'invalid_position',
            details: `Match ${i + 1} placed at default position`,
            session_id: sessionId
          };
          gtag('event', 'game_error', errorData);
          logDebug('Game error', errorData);
        }

        const zIndex = Math.floor(Math.random() * matchCountValue);
        const match = document.createElement('div');
        match.className = 'match';
        if (shadowEnabled) match.classList.add('with-shadow');
        match.style.left = x + 'px';
        match.style.top = y + 'px';
        const displayAngle = (angle - 90 + 360) % 360;
        match.style.transform = `rotate(${displayAngle}deg)`;
        match.style.zIndex = zIndex;

        const head = document.createElement('div');
        head.className = 'match-head';
        match.appendChild(head);
        gameArea.appendChild(match);

        let direction = '';
        let normalizedAngle = (angle + 360) % 360;
        
        if (normalizedAngle >= 45 && normalizedAngle < 135) {
          direction = 'right';
        } else if (normalizedAngle >= 135 && normalizedAngle < 225) {
          direction = 'down';
        } else if (normalizedAngle >= 225 && normalizedAngle < 315) {
          direction = 'left';
        } else {
          direction = 'up';
        }

        matches.push(direction);
        matchPositions.push({ x, y, angle, zIndex });
        placedPositions.push({ x, y });
      }

      setTimeout(() => {
        gameArea.innerHTML = '';
        document.getElementById('check-btn').style.display = 'inline-block';
        activeInput = document.getElementById('up');
        activeInput.classList.add('active');
        logDebug('Matches hidden, ready for answers');
      }, viewTimeValue);
    }

    function calculateDifficulty(matchCount, viewTime) {
      const score = matchCount / viewTime * 1000;
      const difficulty = score < 2 ? 'easy' : score < 5 ? 'medium' : 'hard';
      logDebug('Calculated difficulty', { matchCount, viewTime, difficulty });
      return difficulty;
    }

    function toggleSettings() {
      const settingsPanel = document.getElementById('settings-panel');
      const settingsBtn = document.getElementById('settings-btn');
      const t = translations[currentLanguage];
      if (settingsPanel.style.display === 'flex') {
        settingsPanel.style.display = 'none';
        settingsBtn.textContent = t.settings;
      } else {
        settingsPanel.style.display = 'flex';
        settingsBtn.textContent = t.settings_on;
        const eventData = { session_id: sessionId };
        gtag('event', 'view_settings', eventData);
        logDebug('Settings panel toggled', eventData);
      }
      lastInteraction = performance.now();
    }

    function toggleKeyboard() {
      keyboardEnabled = !keyboardEnabled;
      const keyboard = document.getElementById('custom-keyboard');
      const toggleBtn = document.getElementById('toggle-keyboard-btn');
      const t = translations[currentLanguage];
      if (keyboardEnabled) {
        keyboard.style.display = 'grid';
        toggleBtn.textContent = t.keyboard_on;
      } else {
        keyboard.style.display = 'none';
        toggleBtn.textContent = t.keyboard;
      }
      const eventData = {
        enabled: keyboardEnabled,
        session_id: sessionId
      };
      gtag('event', 'toggle_keyboard', eventData);
      logDebug('Keyboard toggled', eventData);
      setUserProperties();
      lastInteraction = performance.now();
    }

    function toggleShadow() {
      shadowEnabled = !shadowEnabled;
      const shadowBtn = document.getElementById('shadow-btn');
      const matches = document.querySelectorAll('.match');
      const t = translations[currentLanguage];
      if (shadowEnabled) {
        shadowBtn.textContent = t.shadow_on;
        matches.forEach(match => match.classList.add('with-shadow'));
      } else {
        shadowBtn.textContent = t.shadow;
        matches.forEach(match => match.classList.remove('with-shadow'));
      }
      const eventData = {
        enabled: shadowEnabled,
        session_id: sessionId
      };
      gtag('event', 'toggle_shadow', eventData);
      logDebug('Shadow toggled', eventData);
      setUserProperties();
      lastInteraction = performance.now();
    }

    function toggleTheme() {
      isDarkTheme = !isDarkTheme;
      const themeBtn = document.getElementById('theme-btn');
      const body = document.body;
      const t = translations[currentLanguage];
      
      if (isDarkTheme) {
        body.classList.remove('light-theme');
        themeBtn.textContent = t.night;
      } else {
        body.classList.add('light-theme');
        themeBtn.textContent = t.day;
      }

      const eventData = {
        enabled: isDarkTheme ? 'dark' : 'light',
        session_id: sessionId
      };
      gtag('event', 'toggle_theme', eventData);
      logDebug('Theme toggled', eventData);
      setUserProperties();
      lastInteraction = performance.now();
    }

    function changeLanguage() {
      currentLanguage = document.getElementById('language-select').value;
      logDebug('Language changed', { language: currentLanguage });
      
      const t = translations[currentLanguage];
      
      document.getElementById('start-btn').textContent = t.start;
      document.getElementById('check-btn').textContent = t.check;
      document.getElementById('new-game-btn').textContent = t.new_game;
      document.getElementById('settings-btn').textContent = t.settings;
      document.getElementById('close-rules-btn').textContent = t.close;
      document.getElementById('toggle-keyboard-btn').textContent = keyboardEnabled ? t.keyboard_on : t.keyboard;
      document.getElementById('shadow-btn').textContent = shadowEnabled ? t.shadow_on : t.shadow;
      document.getElementById('theme-btn').textContent = isDarkTheme ? t.night : t.day;
      document.getElementById('rules-btn').textContent = t.rules;
      
      document.querySelector('#settings-panel .setting-row:nth-child(1) label').textContent = t.keyboard + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(2) label').textContent = t.language + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(3) label').textContent = t.shadow + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(4) label').textContent = t.rules + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(5) label').textContent = t.match_count + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(6) label').textContent = t.view_time + ':';
      document.querySelector('#settings-panel .setting-row:nth-child(7) label').textContent = t.theme + ':';
      
      document.getElementById('question').textContent = t.question;
      document.querySelector('#result-panel .result-row:nth-child(2) label').textContent = t.up;
      document.querySelector('#result-panel .result-row:nth-child(3) label').textContent = t.down;
      document.querySelector('#result-panel .result-row:nth-child(4) label').textContent = t.right;
      document.querySelector('#result-panel .result-row:nth-child(5) label').textContent = t.left;
      
      document.querySelector('#custom-keyboard button:last-child').textContent = t.ok;
      document.querySelector('#custom-keyboard .delete-btn').textContent = t.delete;
      
      document.getElementById('rules-content').innerHTML = t.rules_content;
      
      viewTimeDisplay.textContent = parseInt(viewTimeDisplay.textContent) + ' ' + t.seconds;
      
      const eventData = {
        language: currentLanguage,
        session_id: sessionId
      };
      gtag('event', 'change_language', eventData);
      setUserProperties();
      lastInteraction = performance.now();
    }

    function addNumber(number) {
      if (!activeInput) return;
      let currentValue = activeInput.value || '';
      if (currentValue.length < 2) {
        activeInput.value = currentValue + number;
        const eventData = {
          key_pressed: number,
          input_field: activeInput.id,
          session_id: sessionId
        };
        gtag('event', 'keyboard_interaction', eventData);
        logDebug('Number added', eventData);
      }
      lastInteraction = performance.now();
    }

    function deleteNumber() {
      if (!activeInput) return;
      activeInput.value = activeInput.value.slice(0, -1);
      const eventData = {
        key_pressed: 'delete',
        input_field: activeInput.id,
        session_id: sessionId
      };
      gtag('event', 'keyboard_interaction', eventData);
      logDebug('Number deleted', eventData);
      lastInteraction = performance.now();
    }

    function toggleRules() {
      const rules = document.getElementById('rules');
      if (rules.style.display === 'block') {
        rules.style.display = 'none';
      } else {
        rules.style.display = 'block';
        const eventData = { session_id: sessionId };
        gtag('event', 'view_rules', eventData);
        logDebug('Rules toggled', eventData);
      }
      lastInteraction = performance.now();
    }

    function trackAchievement(achievementType, matchCount, viewTime) {
      const eventData = {
        achievement_type: achievementType,
        match_count: matchCount,
        view_time: viewTime,
        session_id: sessionId
      };
      gtag('event', 'achievement_unlocked', eventData);
      logDebug('Achievement unlocked', eventData);
    }

    function checkAnswers() {
      logDebug('Checking answers');
      const up = parseInt(document.getElementById('up').value) || 0;
      const down = parseInt(document.getElementById('down').value) || 0;
      const right = parseInt(document.getElementById('right').value) || 0;
      const left = parseInt(document.getElementById('left').value) || 0;

      const actual = {
        up: matches.filter(d => d === 'up').length,
        down: matches.filter(d => d === 'down').length,
        right: matches.filter(d => d === 'right').length,
        left: matches.filter(d => d === 'left').length
      };

      const correctCount = (up === actual.up ? 1 : 0) + 
                          (down === actual.down ? 1 : 0) + 
                          (right === actual.right ? 1 : 0) + 
                          (left === actual.left ? 1 : 0);
      const totalMatches = matches.length;
      const duration = Math.round((performance.now() - gameStartTime) / 1000);
      const errorMagnitude = {
        up: Math.abs(up - actual.up),
        down: Math.abs(down - actual.down),
        right: Math.abs(right - actual.right),
        left: Math.abs(left - actual.left)
      };

      document.getElementById('feedback-up').innerHTML = `<span class="${up === actual.up ? 'correct' : 'incorrect'}">${actual.up}</span>`;
      document.getElementById('feedback-down').innerHTML = `<span class="${down === actual.down ? 'correct' : 'incorrect'}">${actual.down}</span>`;
      document.getElementById('feedback-right').innerHTML = `<span class="${right === actual.right ? 'correct' : 'incorrect'}">${actual.right}</span>`;
      document.getElementById('feedback-left').innerHTML = `<span class="${left === actual.left ? 'correct' : 'incorrect'}">${actual.left}</span>`;

      const gameArea = document.getElementById('game-area');
      gameArea.innerHTML = '';
      matchPositions.forEach(pos => {
        const match = document.createElement('div');
        match.className = 'match';
        if (shadowEnabled) match.classList.add('with-shadow');
        match.style.left = pos.x + 'px';
        match.style.top = pos.y + 'px';
        const displayAngle = (pos.angle - 90 + 360) % 360;
        match.style.transform = `rotate(${displayAngle}deg)`;
        match.style.zIndex = pos.zIndex;

        const head = document.createElement('div');
        head.className = 'match-head';
        match.appendChild(head);
        gameArea.appendChild(match);
      });

      const checkEventData = {
        correct_count: correctCount,
        user_answers: JSON.stringify({ up, down, right, left }),
        actual_answers: JSON.stringify(actual),
        error_magnitude: JSON.stringify(errorMagnitude),
        session_id: sessionId,
        user_id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous'
      };
      gtag('event', 'check_answers', checkEventData);
      logDebug('Answers checked', checkEventData);

      const completeEventData = {
        correct_answers: correctCount,
        total_matches: totalMatches,
        duration: duration,
        match_distribution: JSON.stringify(actual),
        session_id: sessionId,
        user_id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous'
      };
      gtag('event', 'game_complete', completeEventData);
      logDebug('Game completed', completeEventData);

      if (correctCount === 4) {
        trackAchievement('perfect_score', totalMatches, viewTime / 1000);
      }

      document.getElementById('new-game-btn').style.display = 'inline-block';
      document.getElementById('check-btn').style.display = 'none';
      lastInteraction = performance.now();
    }

    function resetGame(event) {
      event.stopPropagation();
      restartCount++;
      logDebug('Resetting game', { restartCount });
      document.getElementById('new-game-btn').style.display = 'none';
      document.getElementById('start-btn').style.display = 'block';
      document.getElementById('check-btn').style.display = 'none';
      document.getElementById('up').value = '';
      document.getElementById('down').value = '';
      document.getElementById('right').value = '';
      document.getElementById('left').value = '';
      document.getElementById('feedback-up').innerHTML = '';
      document.getElementById('feedback-down').innerHTML = '';
      document.getElementById('feedback-right').innerHTML = '';
      document.getElementById('feedback-left').innerHTML = '';
      gameStarted = false;

      const eventData = {
        restart_count: restartCount,
        session_id: sessionId,
        user_id: window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 'anonymous'
      };
      gtag('event', 'game_restart', eventData);
      logDebug('Game restarted', eventData);

      startGame();
      lastInteraction = performance.now();
    }

    function changeMatchCount(delta) {
      let currentValue = parseInt(matchCountDisplay.textContent);
      let newValue = currentValue + delta;
      
      if (newValue >= 3 && newValue <= 80) {
        matchCountDisplay.textContent = newValue;
        matchCount = newValue;
        const eventData = {
          setting_type: 'match_count',
          value: newValue,
          session_id: sessionId
        };
        gtag('event', 'change_settings', eventData);
        logDebug('Match count changed', eventData);
        setUserProperties();
      }
      lastInteraction = performance.now();
    }

    function changeViewTime(delta) {
      let currentValue = parseInt(viewTimeDisplay.textContent.replace(translations[currentLanguage].seconds, '').trim());
      let newValue = currentValue + delta;
      
      if (newValue >= 1 && newValue <= 30) {
        viewTimeDisplay.textContent = newValue + ' ' + translations[currentLanguage].seconds;
        viewTime = newValue * 1000;
        const eventData = {
          setting_type: 'view_time',
          value: newValue,
          session_id: sessionId
        };
        gtag('event', 'change_settings', eventData);
        logDebug('View time changed', eventData);
        setUserProperties();
      }
      lastInteraction = performance.now();
    }

    function changeAnswer(direction, delta) {
      const input = document.getElementById(direction);
      let currentValue = parseInt(input.value) || 0;
      let newValue = currentValue + delta;
      
      if (newValue >= 0 && newValue <= 80) {
        input.value = newValue;
        logDebug('Answer changed', { direction, delta, newValue });
      }
      lastInteraction = performance.now();
    }

    window.Telegram.WebApp.expand();
  </script>
</body>
</html>
